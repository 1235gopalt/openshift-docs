[[scaling-performance-capacity-host-practices]]
= Recommended Host Practices
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:

[[scaling-performance-capacity-host-practices-master]]
== Recommended Practices for {product-title} Master Hosts

In addition to pod traffic, the most-used data-path in an {product-title}
infrastructure is between the {product-title} master hosts and etcd. The
{product-title} API server (part of the master binary) consults etcd for node
status, network configuration, secrets, and more.

Optimize this traffic path by:

* Co-locating master hosts and etcd servers.

* Ensuring an uncongested, low latency LAN communication link between master hosts.

* Ensuring the first etcd server listed in
 *_/etc/origin/master/master-config.yaml_* is the local etcd instance.

[[scaling-performance-capacity-host-practices-node]]
== Recommended Practices for {product-title} Node Hosts

The {product-title} node configuration file at
*_/etc/origin/node/node-config.yaml_* contains important options such as the
iptables synchronization period, the Maximum Transmission Unit (MTU) of the SDN network, and the proxy-mode.

The node configuration file allows you to pass arguments to the kubelet
(node) process. You can view a list of possible options by running `kubelet
--help`.

[NOTE]
====
Not all kubelet options are supported by {product-title}, and are used in the
upstream Kubernetes. This means certain options are in limited support.
====

One of the most commonly discussed node options is
xref:../admin_guide/manage_nodes.adoc#admin-guide-max-pods-per-node[`max-pods`],
which limits the number of pods that can run on a node at any given time.
Exceeding the `max-pods` values can result in:

* Increased CPU utilization on both {product-title} and Docker.
* Slow pod scheduling.
* Potential out-of-memory scenarios (depends on the amount of memory in the node).
* Exhausting the pool of IP addresses.
* Resource overcommitting, leading to poor user application performance.

[NOTE]
====
In Kubernetes, a pod that is holding a single
container actually uses two containers. The second container is used to set up
networking prior to the actual container starting. Therefore, a system running
10 pods will actually have 20 containers running.
====

See the xref:../install_config/install/planning.adoc#sizing[Sizing
Considerations] section in the installation documentation for the recommended
limits for an {product-title} cluster. The recommended sizing accounts for
{product-title} and Docker coordination for container status updates. This
coordination puts CPU pressure on the master and docker processes, which can
include writing a large amount of log data.

[[scaling-performance-capacity-host-practices-etcd]]
== Recommended Practices for OpenShift etcd Hosts

etcd is a distributed key-value store that {product-title} uses for
configuration.

[IMPORTANT]
====
After profiling etcd under {product-title}, etcd frequently performs small
amounts of storage input and output. Using etcd with storage that handles small
read/write operations quickly, such as SSD, is highly recommended.
====

Optimize communication between etcd and master hosts either by co-locating
them on the same host, or providing a dedicated network.

[NOTE]
====
etcd hosts are typically memory intensive.
====

[[scaling-performance-capacity-tuned-profile]]
== Scaling Hosts Using the Tuned Profile

{product-title} disables the `tuned` daemon, which is enabled by default in Red
Hat Enterprise Linux. This monitors component activity and reacts to any
changes.

Instead, {product-title} includes Tuned profiles called `atomic-openshift-host`
and `atomic-openshift-guest`. These profiles safely increase some of the
commonly encountered vertical scaling limits present in the kernel, and are
automatically applied to your system during installation. 

The Tuned profiles support inheritance between profiles. On an {product-title}
system, the findings delivered by Tuned will be the union of
`throughput-performance` (the default for RHEL) and `atomic-openshift-guest`.
Tuned will determine if you are running {product-title} on a virtual machine,
and, if so, automatically apply `virtual-guest` tuning as well.

